import argparse
import struct
import json
import binascii
import hmac
import hashlib


class Encoder:
    def __init__(self, secrets: bytes):
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """
        # Load the json of the secrets file
        secrets = json.loads(secrets)

        # Extract the secret key for HMAC verification
        self.hmac_key = binascii.unhexlify(secrets["some_secrets"])

    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

        :param channel: 32b unsigned channel number
        :param frame: Frame to encode (Max: 64 bytes)
        :param timestamp: 64b timestamp

        :returns: The encoded frame, which will be sent to the Decoder
        """
        # Ensure frame is exactly 64 bytes
        if len(frame) > 64:
            raise ValueError(f"Frame size exceeds 64 bytes (got {len(frame)} bytes)")

        # Pad frame with zeros if it is less than 64 bytes
        frame = frame.ljust(64, b'\x00')

        # Create the payload with channel + timestamp + frame data
        payload = struct.pack("<IQ", channel, timestamp) + frame

        # Generate HMAC signature
        signature = hmac.new(self.hmac_key, payload, hashlib.sha256).digest()

        # Debugging output
        print(f"Frame Length Before Encoding: {len(frame)}")
        print(f"Payload Length (without HMAC): {len(payload)}")
        print(f"Signature Length: {len(signature)}")
        print(f"Total Encoded Frame Length: {len(payload + signature)}")

        return payload + signature


def main():
    """A test main to one-shot encode a frame

    Usage:
        python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
    """
    parser = argparse.ArgumentParser(prog="ectf25_design.encoder")
    parser.add_argument(
        "secrets_file", type=argparse.FileType("rb"), help="Path to the secrets file"
    )
    parser.add_argument("channel", type=int, help="Channel to encode for")
    parser.add_argument("frame", help="Contents of the frame")
    parser.add_argument("timestamp", type=int, help="64b timestamp to use")
    args = parser.parse_args()

    encoder = Encoder(args.secrets_file.read())
    print(repr(encoder.encode(args.channel, args.frame.encode(), args.timestamp)))


if __name__ == "__main__":
    main()
